


          
# Подробное описание скрипта настройки Elasticsearch

## 1. Параметры подключения
```bash
ES_HOST="localhost:9200"
ES_USER="admin"
ES_PASS="admin"
```
Эти параметры определяют:
- `ES_HOST`: адрес и порт кластера Elasticsearch
- `ES_USER`: имя пользователя для аутентификации
- `ES_PASS`: пароль для аутентификации

## 2. Функция es_request
```bash
es_request() {
    local method=$1
    local endpoint=$2
    local data=$3
    ...
}
```
Универсальная функция для выполнения HTTP-запросов к Elasticsearch:
- Поддерживает все HTTP методы (GET, PUT, POST, DELETE)
- Автоматически добавляет заголовки Content-Type
- Включает базовую аутентификацию
- Обрабатывает JSON-данные

## 3. Настройка памяти и системных параметров
```yaml
# Системные настройки
bootstrap.memory_lock: true
cluster.name: replication-cluster
node.name: replication-node
```
- `bootstrap.memory_lock`: предотвращает свопинг памяти Elasticsearch
- `cluster.name`: уникальное имя кластера
- `node.name`: уникальное имя узла

## 4. Настройки производительности
```yaml
indices.memory.index_buffer_size: 30%
indices.queries.cache.size: 15%
indices.fielddata.cache.size: 20%
```
- Буфер индексации: 30% от heap
- Кэш запросов: 15% от heap
- Кэш полевых данных: 20% от heap
- Оптимизировано для больших объемов данных

## 5. Настройки JVM
```
-Xms4g
-Xmx4g
-XX:+UseG1GC
```
- Одинаковый минимальный и максимальный размер кучи
- Использование G1 сборщика мусора
- Оптимизация для больших куч

## 6. Настройки безопасности
```yaml
xpack.security.enabled: true
xpack.security.transport.ssl.enabled: true
```
- Включение X-Pack security
- Активация SSL для транспортного уровня
- Создание административного пользователя

## 7. Оптимизация репликации
```json
{
  "persistent": {
    "indices.recovery.max_bytes_per_sec": "100mb",
    "indices.recovery.concurrent_streams": 5
  }
}
```
- Увеличение скорости передачи данных
- Настройка параллельных потоков
- Оптимизация восстановления

## 8. Шаблоны индексов
```json
{
  "index_patterns": ["*"],
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  }
}
```
- Применяется ко всем новым индексам
- Оптимальное количество шардов
- Настройка репликации
- Асинхронные транзакционные логи

## 9. Политика ILM
```json
{
  "policy": {
    "phases": {
      "hot": { ... },
      "warm": { ... },
      "cold": { ... },
      "delete": { ... }
    }
  }
}
```
- Hot фаза: активные данные, максимальная производительность
- Warm фаза: оптимизация хранения
- Cold фаза: архивные данные
- Delete фаза: автоматическое удаление

### 9.1 Подробное описание политики ILM




          
# Подробное описание политики ILM (Index Lifecycle Management)

## Что такое ILM?
ILM - это автоматическое управление жизненным циклом индексов в Elasticsearch. Политика определяет, как индекс должен управляться на разных этапах своего существования.

## Фазы жизненного цикла

### 1. Hot Phase (Горячая фаза)
```json
"hot": {
    "min_age": "0ms",
    "actions": {
        "rollover": {
            "max_age": "30d",
            "max_size": "50gb",
            "max_docs": 100000000
        },
        "set_priority": {
            "priority": 100
        }
    }
}
```
- **Назначение**: Активные данные, которые часто запрашиваются и обновляются
- **Параметры**:
  - `max_age`: 30 дней максимум
  - `max_size`: до 50GB размера индекса
  - `max_docs`: до 100 миллионов документов
  - `priority`: 100 (высший приоритет для поиска)
- **Когда срабатывает**: При достижении любого из условий (возраст/размер/количество документов)

### 2. Warm Phase (Теплая фаза)
```json
"warm": {
    "min_age": "30d",
    "actions": {
        "shrink": {
            "number_of_shards": 1
        },
        "forcemerge": {
            "max_num_segments": 1
        },
        "set_priority": {
            "priority": 50
        },
        "allocate": {
            "number_of_replicas": 1
        }
    }
}
```
- **Назначение**: Старые данные, которые читаются реже
- **Действия**:
  - `shrink`: Уменьшение количества шардов до 1
  - `forcemerge`: Принудительное слияние сегментов для оптимизации
  - `priority`: 50 (средний приоритет)
  - `replicas`: 1 копия для надежности

### 3. Cold Phase (Холодная фаза)
```json
"cold": {
    "min_age": "60d",
    "actions": {
        "set_priority": {
            "priority": 0
        },
        "allocate": {
            "number_of_replicas": 0
        },
        "freeze": {}
    }
}
```
- **Назначение**: Редко используемые данные
- **Действия**:
  - `priority`: 0 (низкий приоритет)
  - `replicas`: Удаление реплик для экономии места
  - `freeze`: Заморозка индекса для минимизации использования памяти

### 4. Delete Phase (Фаза удаления)
```json
"delete": {
    "min_age": "90d",
    "actions": {
        "delete": {
            "delete_searchable_snapshot": true
        }
    }
}
```
- **Назначение**: Удаление устаревших данных
- **Когда**: После 90 дней
- **Действие**: Полное удаление индекса

## Как это работает на практике

1. **Новые данные**:
   - Попадают в hot фазу
   - Максимальная производительность
   - Все реплики активны

2. **Через 30 дней**:
   - Переход в warm фазу
   - Оптимизация хранения
   - Уменьшение количества шардов

3. **Через 60 дней**:
   - Переход в cold фазу
   - Заморозка данных
   - Минимум реплик

4. **Через 90 дней**:
   - Автоматическое удаление
   - Освобождение места

## Рекомендации по настройке

1. **Размеры индексов**:
   - Настройте `max_size` под ваши объемы
   - Учитывайте скорость роста данных

2. **Временные интервалы**:
   - Измените `min_age` под ваши требования
   - Учитывайте важность исторических данных

3. **Количество реплик**:
   - В hot фазе больше реплик для надежности
   - В cold фазе минимум реплик для экономии

4. **Приоритеты**:
   - Hot: 100 для быстрого поиска
   - Warm: 50 для баланса
   - Cold: 0 для архивных данных

## 10. Проверка статуса
```bash
es_request GET "_cluster/health"
```
- Проверка здоровья кластера
- Статус узлов
- Состояние шардов
- Подтверждение применения настроек

Каждый из этих компонентов тщательно настроен для обеспечения:
- Максимальной производительности
- Надежности данных
- Эффективного использования ресурсов
- Автоматического управления жизненным циклом данных

